# 背景

### 微前端现状

自微前端提出以来，各大公司和前端社区出现了一些高质量的微前端框架，例如：single-spa，qiankun，micro-app。他们很好的解决了微前端的聚合问题。随着微前端的不断发展，微前端不再仅仅用在内部管理系统，越来越多的对外 toB 的项目使用微前端，而他们具有一些显著的特点：业务复杂，交互复杂，应用间依赖关系复杂。

在复杂的微前端项目中，上述微前端框架都遇到了一些挑战。我们由浅入深来看以下问题：


#### 案例1

现有一个主应用和A、B、C 三个子应用

##### 需求一期

有一个弹窗，所有页面都需要弹出，于是，很开心的在主应用中写

```js
showModal()
```

##### 需求二期

现在 A 应用的路由下 /a/a1 不谈这个窗，于是，很开心的在主应用中写

```js
if (!location.path.startWith('/a/a1')) {
  showModal()
}
```

##### 需求三期

现在 B 应用的路由下 /b/b1 不弹这个窗，于是你思考了，能不能不要每次让我做这种业务需求，这种就应该 B 应用自己实现，于是你便有这种期待

```js
// 主应用
const currentMatchedApp = getMatchedApp()
if (!currentMatchedApp.notShowModal) {
  showModal()
}

// 子应用 B 有个地方配置
const config = [
  {
    path: '/b/b1',
    notShowModal: true
  }
]
```

可以怎么拿取到 B 应用的这个配置呢？

##### 需求四期

现在 C 应用的路由下 /c/c1 想在弹窗中增加一段自定义文案，于是便把组件给了他们

```js
// 主应用
const currentMatchedApp = getMatchedApp()
if (!currentMatchedApp.notShowModal) {
  showModal()
}
export { showModal }

// 子应用 C 有个地方配置
const config = {
  notShowModal: true
}
// 子应用 C 某处执行
showModal()
```

#### 案例1总结

从上面这个例子看出，微前端并不能完全割裂应用关系，至少子应用和主应用还有一些联系

#### 案例2

现在有一个主应用由 P1 团队负责，有一个子应用 A 由 P2 团队负责，是一个广告业务团队，有一个子应用 B 由 P3 团队负责，是一个数据团队负责。

##### 需求一期
用户在 A 应用的 /a/a1 页面投广告，在 B 应用 /b/b1 页面可以看到广告数据，两个团队各自开发

##### 需求二期
接到用户投诉，每次到 /b/b1 看数据麻烦，而且我希望调整我的广告投放之后，能在 /a/a1 页面下面预算出一个预计花费的图。

于是产品安排：在 /a/a1 页面增加已经投放的广告数据，只是一个简化的数据，然后上面有一个详细按钮，跳转到 /b/b1 ，于是 P2 团队的前端和 P3 团队的后端开发一个简化的广告数据展示。

##### 需求三期
用户希望在 /a/a1 下再增加一个图，看到点击和收益。

于是产品安排：在 /a/a1 加了一个 tab，可以切换图表数据，也就是 /a/a1/c1 上面展示广告业务，下面展示广告数据，点击 tab 切换之后，上面内容不变，下面变成点击和收益数据，并且链接是 /a/a1/c2

#### 需求四期
产品希望在图上增加更为复杂的数据展示，于是作为 P2 广告团队的前端开发，你想了一下，不愿意继续做 P3 数据团队的业务了，每次都要我们为他们开发功能。于是你有了设想：

/a/a1/c1
/a/a1/c2
这两个页面的上半部分我们负责，我们在下面嵌套你们的那一部分。

/a/a1/c1
/a/a1/c2
这两个页面的下半部分 和 /b/b1 由数据团队负责

可是，这个要怎么实现呢？

于是你发现 micro-app 很好的解决了这个问题

#### 需求五期-性能优化
/a/a1/c1，用户打开这个路由时，目前流程是：
加载 A 应用 -> 渲染 A 应用 -> 加载 B 应用 -> 渲染 B 应用

是否应该改成如下流程
同时加载 A，B 应用 -> 渲染 A 应用 -> 渲染 B 应用

这个又怎么实现呢？

#### 案例2总结
应用与应用之间还可能存在嵌套关系

#### 案例3

现有一个主应用和 A，B 两个子应用，A 潜套 B

##### 需求一期

A 应用需要用户拥有权限 a，B 应用需要用户拥有权限 b，各应用独立处理

##### 需求二期-Bug修复
一个无权限的用户进入/a/b 这个页面，会闪一下 A，然后闪一下 B，然后才是无权限页面，你应该最开始直接跳转无权限页面

这怎么修复？你犯难了。

##### 需求三期-权限收归主应用
于是你在主应用中愉快的添加了如下配置

```js
const permission = {
  path: '/a',
  access: 'a', // 需要 a 权限
  children: [{
    path: '/a1',
    access: 'a1' // 同时需要 a 权限和 a1 权限
  }, {
    path: '/b',
    access: 'bbb' // 同时需要 a 权限和 b 权限
  }]
}
```

然后你自己做了一套路由匹配，然后你写出了 Bug，你的路由匹配规则和微前端框架的应用匹配规则不一致。你便思考一下两个问题：

1. qiankun 这种做了路由匹配的，这个问题不应该完全由我解决，框架做了路由匹配，应该做好这件事情。
2. micro-app 这种没做路由匹配的，我目前主应用用了 vue，每个权限信息配置在vue-router 的 meta 里面，可是我主应用只能配置到 /a 这一级别，/a/a1 和 /a/b 这种怎么配置呢？

#### 案例4

现有一个主应用和 A，B 两个子应用，A 应用路径/a，B 应用路径 /b

##### 需求一期
主应用需要做一个统一的 404 页面，当没有应用的页面匹配到是，展示这个页面。

于是，每个子应用去除了自己的 404 页面，可是，你犯难了，我怎么知道当前的 url 是不会展示页面的？我只知道 /a 需要渲染 A 应用。

例如：

/a/a1：A 子应用 的 a1 页面

/a/a2：A 子应用 的 a2 页面

/a/xxxxxxxxxxxx(用户随便输入)：A 子应用无法匹配，显示404

于是，你设计了一种通讯方式，A 应用匹配不到时通知主应用

##### Bug

因为上面的设计，你带来了一个Bug。

每次用户进入 /a/xxxxxxxxxxxx 都会很慢，要先加载 A，然后才知道404
每次用户进入 /a/xxxxxxxxxxxx 都会闪一下 A 应用某些内容，然后展示 404


#### 案例5

现在有一个主应用由 P1 团队负责，有一个子应用 A 由 P2 团队负责，有一个子应用 B 也由 P2 团队负责。

##### 需求一期
A 和 B 应用有很多类似的业务，于是，你考虑做一个业务组件包管理公用的组件，A 和 B 应用分别引入这个包

##### 需求二期
两个值得思考的问题：
1. A 和 B 是我们一个团队负责，是同一技术栈，有些接口，数据，store，埋点还需要公用，我怎么做呢，为什么A，B 两个应用要分别去处理这些事情。
2. 之前的公用的组件为什么每个应用都要去加载自己的版本，而不是一个版本，我改动一个地方就行。

是不是可以创建一个没有路由的 C 应用，承载上面的逻辑。

之前流程:

/a: 加载 A 应用 -> 初始化 store，埋点等 -> 渲染 A 应用

/b: 加载 B 应用 -> 初始化 store，埋点等 -> 渲染 B 应用

改动之后：
/a: 知道加载 A 应用，A 依赖 C -> 加载 C 应用 -> 初始化 store，埋点等 -> 加载 A 应用 -> 渲染 A 应用

改动的好处：
1. 改动之前，修改组件包，要分别修改 A 和 B 的版本。现只需要修改 C 的版本
2. store，埋点 等能力可以被公用，而不是像改动之前每次这些逻辑变更需要改A，B 两个应用。

### versea 解决的问题
