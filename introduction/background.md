# 背景

### 微前端现状

自微前端提出以来，各大公司和前端社区出现了一些高质量的微前端框架，例如：single-spa，qiankun，micro-app。他们很好的解决了微前端的聚合问题。随着微前端的不断发展，微前端不再仅仅用在内部管理系统，越来越多的对外 toB 的项目使用微前端，而他们具有一些显著的特点：业务复杂，交互复杂，应用间依赖关系复杂。

在复杂的微前端项目中，上述微前端框架都遇到了一些挑战。我们由浅入深来看以下问题：


#### 案例1

现有一个主应用和A、B、C 三个子应用。

##### 需求一期

现在需要增加一个弹窗，所有页面都需要弹出，于是在主应用中很开心的写了如下代码：

```js
showModal()
```

##### 需求二期

产品提了一个特殊需求：现在 A 应用的路由下 /a/a1 不弹出这个 modal，于是在主应用中很开心的写了如下代码：

```js
if (!location.path.startWith('/a/a1')) {
  showModal()
}
```

##### 需求三期

现在 B 应用的路由下 /b/b1 不弹出这个 modal，于是你开始思考了，能不能不要每次让我做这种业务需求，这种应该 B 应用自己实现，于是你期待能用以下代码实现：

```js
// 主应用
const currentMatchedApp = getMatchedApp()
if (!currentMatchedApp.notShowModal) {
  showModal()
}

// 子应用 B 有个地方配置
const config = [
  {
    path: '/b/b1',
    notShowModal: true
  }
]
```

可以怎么拿取到 B 应用的这个配置呢？

##### 需求四期

现在 C 应用的路由 /c/c1 这个页面想在弹窗中增加一段自定义文案，于是把组件给了 C 应用：

```js
// 主应用
const currentMatchedApp = getMatchedApp()
if (!currentMatchedApp.notShowModal) {
  showModal()
}
export { showModal }

// 子应用 C 有个地方配置
const config = {
  notShowModal: true
}
// 子应用 C 某处执行
showModal()
```

#### 案例1总结

重要的不是需求三期和需求四期怎么去解决，而是了解了另一种形态的微前端。似乎以前只了解到应用间应该是隔离关系，现在发现应用间可能还存在耦合关系。

#### 案例2

现在有一个主应用由 P1 团队负责，有一个子应用 A 由 P2 团队负责，是一个广告业务团队；有一个子应用 B 由 P3 团队负责，是一个数据团队负责。

主应用路由规则：/a -> 渲染 子应用 A，/b -> 渲染 子应用 B。

##### 需求一期
用户在 A 应用的 /a/a1 页面投广告，在 B 应用 /b/b1 页面可以看到广告数据，两个团队各自开发。

##### 需求二期
接到用户投诉，每次到 /b/b1 看数据麻烦，而且我希望调整我的广告投放之后，能在 /a/a1 页面下面预算出一个预计花费的图。

于是产品增加需求：在 /a/a1 页面增加已经投放的广告数据，这次只是展示一个简化的数据，然后在这个简化的数据上放一个"详情"按钮，跳转到 /b/b1 ，于是 P2 团队的前端和 P3 团队的后端开发一个简化的广告数据展示。

##### 需求三期
用户希望在 /a/a1 下再增加一个图，看到点击和收益。

于是产品增加需求：在 /a/a1 加了一个 tab，可以切换图表数据，也就是 /a/a1/c1 上面展示广告业务，下面展示广告数据，点击 tab 切换之后，上面内容不变，下面变成点击和收益数据，并且链接改成 /a/a1/c2

#### 需求四期
产品希望在图上增加更为复杂的数据展示，于是作为 P2 广告团队的前端开发，你想了一下，不愿意继续做 P3 数据团队的业务了，每次都要我为他们开发功能。于是你有了设想：

/a/a1/c1 和 /a/a1/c2 这两个页面的上半部分由 P2 广告团队负责，我们在下面嵌套 P3 数据团队的那一部分。/a/a1/c1 /a/a1/c2 这两个页面的下半部分 和 /b/b1 由数据团队负责。

可是，这个要怎么实现呢？你发现 micro-app，qiankun 好像解决不了这个问题。

#### 需求五期-性能优化
/a/a1/c1，用户打开这个路由时，目前流程是：加载 A 应用 -> 渲染 A 应用 -> 加载 B 应用 -> 渲染 B 应用。

是否应该改成如下流程：同时加载 A，B 应用 -> 渲染 A 应用 -> 渲染 B 应用。

这个又怎么实现呢？

#### 案例2总结
案例2看完，你应该有点感觉了，应用与应用之间的关系越来越复杂了。不止主子应用间存在关联关系，子应用之间还可能存在关联关系。

#### 案例3

现有一个主应用和 A，B 两个子应用，A 嵌套 B

##### 需求一期

A 应用需要用户拥有权限 a，B 应用需要用户拥有权限 b，各应用独立处理

##### 需求二期-Bug修复

一个有 a 权限没有 b 权限的用户进入 /a/b 这个页面，会闪一下 A，然后闪一下 B，然后才是无权限页面，是否应该不需要加载 A 和 B 直接跳转无权限页面。这个 Bug 似乎很难修复。

##### 需求三期-权限收归主应用
终于，你等来了产品的好消息，主应用控制权限，于是在主应用中愉快的添加了如下配置：

```js
const permission = {
  path: '/a',
  access: 'a', // 需要 a 权限
  children: [{
    path: '/a1',
    access: 'a1' // 同时需要 a 权限和 a1 权限
  }, {
    path: '/b',
    access: 'bbb' // 同时需要 a 权限和 b 权限
  }]
}
```

然后你自己做了一套路由匹配，然后你写出了 Bug，你的路由匹配规则和微前端框架的应用匹配规则不一致。你便思考一下两个问题：

1. qiankun 这种做了路由匹配的，这个问题不应该完全由我解决，框架做了路由匹配，应该做好这件事情。
2. micro-app 这种没做路由匹配的，我目前主应用用了 vue，每个权限信息配置在vue-router 的 meta 里面，可是我主应用只能配置到 /a 这一级别，/a/a1 和 /a/b 这种怎么配置呢？

#### 案例4

现有一个主应用和 A，B 两个子应用，A 应用路径/a，B 应用路径 /b。

##### 需求一期
主应用需要做一个统一的 404 页面，如果一个页面没有应用的的路由匹配到，那么展示这个页面。

于是，每个子应用去除了自己的 404 页面，可是怎么知道当前的 url 是不会展示页面的？主应用只知道 /a 需要渲染 A 应用。

例如：

/a/a1：A 子应用 的 a1 页面

/a/a2：A 子应用 的 a2 页面

/a/xxxxxxxxxxxx(用户随便输入)：A 子应用无法匹配，显示404

于是，你设计了一种通讯方式，A 应用匹配不到时通知主应用

##### Bug

因为上面的设计，你带来了一个Bug。

每次用户进入 /a/xxxxxxxxxxxx 都会很慢，要先加载 A，然后才知道404；每次用户进入 /a/xxxxxxxxxxxx 都会闪一下 A 应用某些内容，然后展示 404

#### 案例5

现在有一个主应用由 P1 团队负责，有一个子应用 A 由 P2 团队负责，有一个子应用 B 也由 P2 团队负责。

##### 需求一期
A 和 B 应用有很多类似的业务，于是你考虑做一个业务组件包管理公用的组件，A 和 B 应用分别引入这个包

##### 需求二期
两个值得思考的问题：
1. A 和 B 是我们一个团队负责，是同一技术栈，有些接口，数据，store，埋点还需要公用，我怎么做呢，为什么A，B 两个应用要分别去处理这些事情。
2. 之前的公用的组件为什么每个应用都要去加载自己的版本，而不是一个版本，我改动一个地方就行。

是不是可以创建一个没有路由的 C 应用，承载上面的逻辑。

之前流程:

/a: 加载 A 应用 -> 初始化 store，埋点等 -> 渲染 A 应用

/b: 加载 B 应用 -> 初始化 store，埋点等 -> 渲染 B 应用

改动之后：

/a: 知道加载 A 应用，A 依赖 C -> 加载 C 应用 -> 初始化 store，埋点等 -> 加载 A 应用 -> 渲染 A 应用

改动的好处：
1. 改动之前，修改组件包，要分别修改 A 和 B 的版本，现只需要修改 C 的版本。
2. store，埋点 等能力可以被公用，而不是像改动之前每次这些逻辑变更需要改 A，B 两个应用。

### versea 解决的问题

1. 和其他微前端一样，versea 要解决微前端的加载，卸载，渲染问题。
2. 和其他微前端一样，versea 要解决应用间隔离问题。
3. versea 要解决上面的问题，解决微前端的复杂的应用间关系。
4. 越复杂的微前端的场景，自定义要求越高，versea 具有高扩展能力。
